"""
FlightStream STL -> FSM + Polar Scan Tool
-----------------------------------------

Steps:
1. For each (alt, Mach) condition:
   - Use FlightStream Script commands:
       OPEN shell.fsm
       IMPORT STL ...
       PHYSICS ...
       AIR_ALTITUDE <alt>
   - Then use pyFlightscript API to set solver + sweeper
   - FlightStream.exe actually runs, outputting sweep results

2. Organize CL/CD from all conditions into a 3D polar table and save as .npz file for Aviary tabular aero use.

Be careful:
- need FlightStream GUI installed with Python API support.
- need modified shell.fsm that does not contain geometry or physics setup, only the bare minimum
"""

import os
import numpy as np
import pandas as pd
import io
import pyFlightscript as pyfs

# 1. FlightStream executable file (To your GUI application)
FSEXE_PATH = r"C:\Program Files\Altair\2025.1\flightstream\FlightStream_25.1_Windows_x86_64.exe"

# 2. Blank/Shell FSM
SHELL_FSM_PATH = r"C:\Users\AA201\Aviary\aviary\subsystems\aerodynamics\FlightStream_based\shell.fsm"

# 3. STL geometry file path
STL_PATH = r"C:\Users\AA201\Aviary\aviary\subsystems\aerodynamics\FlightStream_based\advanced_single_aisle.stl"

# 4. Reference area / reference length (From wing_ouotput.csv generated by GeometryCreator.py)

refdata = pd.read_csv(r"C:\Users\AA201\Aviary\aviary\subsystems\aerodynamics\FlightStream_based\wing_output.csv",
                      header=None, names=["name", "value"],)
def get_value(refdata, name: str) -> float:
    return float(refdata.loc[refdata["name"] == name, "value"].iloc[0])

SREF = get_value(refdata, "wing_area")  # m^2, from GeometryCreator output
CREF = get_value(refdata, "wing_avg_chord")   # m  
wake_length = get_value(refdata, "fuselage_len")  # m

# 5. Grid definition (altitude in meters, Mach unitless, alpha in degrees)
ALT_GRID   = np.arange(0.0, 12000.0, 3000)   # You can change to feet and convert uniformly on Aviary side
MACH_GRID  = np.arange(0.1, 0.9, 0.2)
ALPHA_GRID = np.arange(-4, 16, 4)                #  [-6, 15] deg

# 6. Output directory and filename
OUTPUT_DIR      = r"C:\Users\AA201\Aviary\aviary\subsystems\aerodynamics\FlightStream_based\fs_polar_output"
OUTPUT_NPZ_PATH = os.path.join(OUTPUT_DIR, "fs_asa_polar.npz")


# ==============================
# Functions Layer
# ==============================

def isa_speed_of_sound(alt_m: float) -> float:
    """
    Simplified ISA speed of sound, used to convert Mach to velocity V.
    Linear temperature variation approximation for altitude < 11 km.
    """
    T0 = 288.15  # K
    a0 = 340.0   # m/s
    lapse = -0.0065  # K/m

    alt_clamped = np.clip(alt_m, 0.0, 11000.0)
    T = T0 + lapse * alt_clamped
    a = a0 * np.sqrt(T / T0)
    return a


def parse_fs_sweep_output(outfile: str) -> pd.DataFrame:
    """
    FlightStream sweeper outputfile CL/CD。
    header location is fixed at line 28. Need pre-check for this if FS version is not 2025.1
    """

    HEADER_LINE = 27  # 0-based index; the  28 row

    # === 1) Read file ===
    with open(outfile, "r", encoding="utf-8", errors="ignore") as f:
        lines = f.readlines()

    # Safety check: insufficient lines
    if len(lines) <= HEADER_LINE:
        raise RuntimeError(f"File too short, missing header: {outfile}")

    # === 2) Parse CSV from line 28 ===
    csv_text = "".join(lines[HEADER_LINE:])

    df = pd.read_csv(
        io.StringIO(csv_text),
        sep=",",
        engine="python",
        skip_blank_lines=True,
    )

    # Strip whitespace from column names
    df.columns = [c.strip() for c in df.columns]

    required_cols = ["AOA (deg)", "CL", "CDi", "CDo"]
    for col in required_cols:
        if col not in df.columns:
            raise RuntimeError(
                f"FS output missing column {col}, current columns: {list(df.columns)}"
            )

    # === 3) Auto-clean footer rows ===
    # Convert key columns to numeric, turn non-numeric rows to NaN, then drop
    for col in required_cols:
        df[col] = pd.to_numeric(df[col].astype(str).str.strip(), errors="coerce")

    df = df.dropna(subset=required_cols)

    # === 4) Output required columns ===
    df["alpha_deg"] = df["AOA (deg)"].astype(float)
    df["CL"]        = df["CL"].astype(float)
    df["CD"]        = df["CDi"].astype(float) + df["CDo"].astype(float)

    return df[["alpha_deg", "CL", "CD"]]


# ==============================
# Core: Execute OPEN+IMPORT STL+PHYSICS+Sweeper for one (alt, Mach) condition
# ==============================

def run_fs_sweep_one_condition(
    shell_fsm: str,
    stl_path: str,
    fsexe_path: str,
    sref: float,
    cref: float,
    alt: float,    # m
    mach: float,
    alpha_grid: np.ndarray,
    cid: str,
    n_procs: int = 22,
) -> pd.DataFrame:
    """
    For a single (alt, Mach) condition:
    - Open shell.fsm
    - Import STL geometry and set PHYSICS (based on your Script file template)
    - Set AIR_ALTITUDE
    - Calculate V from Mach and initialize solver
    - Sweep AoA using sweeper
    - Parse output and return DataFrame(alpha_deg, CL, CD)
    """

    # Output file: avoid overwriting
    out_dir = os.path.join(os.path.dirname(shell_fsm), "sweep_results")
    os.makedirs(out_dir, exist_ok=True)
    outfile = os.path.join(out_dir, f"sweep_{cid}.txt")

    # Calculate velocity
    a = isa_speed_of_sound(alt)
    V = mach * a

    # Calculate sweeper step size
    if alpha_grid.size > 1:
        alpha_min_step = float(np.min(np.diff(alpha_grid)))
    else:
        alpha_min_step = 1.0

    # Clear pyFlightscript buffer
    pyfs.hard_reset()

    # ========= 1) Geometry + Physics: reuse your Script file template =========
    # Equivalent to Script file in GUI... execute the following commands :contentReference[oaicite:1]{index=1}
    
    # Open shell.fsm
    pyfs.fsinit.open_fsm(fsm_filepath=shell_fsm)

    # Import STL geometry
    pyfs.import_mesh(
        geometry_filepath=stl_path,
        file_type="STL", 
        units="METER", 
        clear=True,
    )

    # Physics settings
    pyfs.wake.physics(
        auto_trail_edges=True,
        auto_wake_nodes=True,
        end=True,
    )

    # Altitude (explicitly set once using Script command)
    pyfs.freestream.air_altitude(altitude=alt)

    # ========= 2) Solver initialization & AoA Sweeper (using pyFlightscript high-level API) =========

    # Initialize solver（panel mesh + BC ；surfaces=-1 means all）
    pyfs.solver.initialize_solver(
    solver_model="SUBSONIC_PRANDTL_GLAUERT",
    surfaces=-1,                     # all surfaces
    wake_termination_x=wake_length,  # downstream wake length
    symmetry="NONE",
    stabilization="ENABLE",
    stabilization_strength=1.0,
    )

    pyfs.set_solver.boundary_layer_type(type_value="TRANSITIONAL")
    pyfs.set_solver.viscous_coupling(mode="ENABLE")

    # solver settings, ensure reference_area / length match SREF/CREF
    pyfs.freestream.set_freestream(freestream_type="CONSTANT")
    pyfs.set_solver.ref_area(value=sref)
    pyfs.set_solver.ref_length(length=cref)
    pyfs.set_solver.ref_velocity(value=V)
    pyfs.set_solver.solver_iterations(num_iterations=500)
    pyfs.set_solver.convergence_threshold(threshold=4e-5)
    pyfs.set_solver.set_max_parallel_threads(num_cores=n_procs)

    # AoA sweeper: only sweep angle of attack, keep others constant
    pyfs.execute_solver_sweeper(
        results_filename=outfile,
        angle_of_attack="ENABLE",
        side_slip_angle="DISABLE",
        velocity="DISABLE",
        angle_of_attack_start=float(alpha_grid.min()),
        angle_of_attack_stop=float(alpha_grid.max()),
        angle_of_attack_delta=alpha_min_step,
        side_slip_angle_start=0.0,
        side_slip_angle_stop=0.0,
        side_slip_angle_delta=1.0,
        velocity_start=0.0,
        velocity_stop=0.0,
        velocity_delta=1.0,
        export_surface_data_per_step="DISABLE",
        clear_solution_after_each_run="DISABLE",
        reference_velocity_equals_freestream="ENABLE",
        append_to_existing_sweep="DISABLE",
    )

    # Close FS GUI (script level)
    pyfs.close_flightstream()

    # ========= 3) Write script.txt and actually call FlightStream.exe =========
    pyfs.write_to_file()
    pyfs.execute_fsm_script(fsexe_path=fsexe_path)

    # Clear local buffer
    pyfs.hard_reset()

    # ========= 4) Parse sweep output =========
    df = parse_fs_sweep_output(outfile)
    return df


# ==============================
# Main process: sweep the entire (alt, Mach, alpha) grid to generate 3D polar tables
# ==============================

def build_polar_tables():
    os.makedirs(OUTPUT_DIR, exist_ok=True)

    n_alt   = ALT_GRID.size
    n_mach  = MACH_GRID.size
    n_alpha = ALPHA_GRID.size

    CL_tab = np.zeros((n_alt, n_mach, n_alpha))
    CD_tab = np.zeros_like(CL_tab)

    for i, alt in enumerate(ALT_GRID):
        for j, M in enumerate(MACH_GRID):
            cid = f"a{i}_m{j}"
            print(f"=== Running FS sweep for alt={alt} m, Mach={M}, cid={cid} ===")

            df = run_fs_sweep_one_condition(
                shell_fsm=SHELL_FSM_PATH,
                stl_path=STL_PATH,
                fsexe_path=FSEXE_PATH,
                sref=SREF,
                cref=CREF,
                alt=alt,
                mach=M,
                alpha_grid=ALPHA_GRID,
                cid=cid,
                n_procs=12,
            )

            alpha_sweep = df["alpha_deg"].values
            CL_sweep    = df["CL"].values
            CD_sweep    = df["CD"].values

            # Safety check: ensure sweep covers the range of ALPHA_GRID
            if alpha_sweep.min() > ALPHA_GRID.min() or alpha_sweep.max() < ALPHA_GRID.max():
                print(f"WARNING: sweep alpha range [{alpha_sweep.min()}, {alpha_sweep.max()}] "
                      f"does not fully cover desired [{ALPHA_GRID.min()}, {ALPHA_GRID.max()}].")

            # Interpolate to unified ALPHA_GRID
            CL_tab[i, j, :] = np.interp(ALPHA_GRID, alpha_sweep, CL_sweep)
            CD_tab[i, j, :] = np.interp(ALPHA_GRID, alpha_sweep, CD_sweep)

    # save npz
    np.savez(
        OUTPUT_NPZ_PATH,
        alt_grid=ALT_GRID,
        mach_grid=MACH_GRID,
        alpha_grid=ALPHA_GRID,
        CL_tab=CL_tab,
        CD_tab=CD_tab,
    )

    print("\n=== Done. Polar tables saved ===")
    print(f"File: {OUTPUT_NPZ_PATH}")
    print(f"CL_tab shape = {CL_tab.shape}, CD_tab shape = {CD_tab.shape}")

# ==============================
# load and run
# ==============================

if __name__ == "__main__":
    print("FlightStream STL -> FSM + Polar Scan Tool")
    print(f"  FlightStream exe : {FSEXE_PATH}")
    print(f"  Shell FSM        : {SHELL_FSM_PATH}")
    print(f"  STL geometry     : {STL_PATH}")
    build_polar_tables()


