"""
Optimize aspect ratio of Advanced Single Aisle aircraft to minimize fuel burn.

Connect to the aerodynamic polar database generated by FlightStream
and run a mission trajectory with optimized Mach/altitude profiles.
"""
import numpy as np
import openmdao.api as om
import aviary.api as av
import pandas as pd

# ==== Cost
from aviary.interface import reports as av_reports


def _dummy_input_check_report(*args, **kwargs):
    return


av_reports.input_check_report = _dummy_input_check_report

from jet_cost_builder import JetCostBuilder
from jet_cost_variables import Aircraft
from fs_tabular_utils import (
    build_tabular_from_fs,
    ARAdjustedProblem,
    attach_ar_update_hooks,
    run_ar_sensitivity_test,
    apply_default_cost_inputs,
)

# Path to your aircraft definition file
aircraft_filename = r"C:\Users\AA201\Desktop\Advanced_tabular\advanced_single_aislenew_FLOPS.csv"
optimizer = 'IPOPT'
make_plots = True
max_iter = 500

# FlightStream polar file (.npz)
fs_npz_path = r"C:\Users\AA201\Desktop\Advanced_tabular\fs_polar_output_lowfed\fs_asa_polar.npz"


# Build tabular aero once
CD0_data, CDI_data, cd0_samples, cdi_samples, mach_cdi_samples, CL_samples = build_tabular_from_fs(fs_npz_path)

# Reference geometry from FlightStream
BASELINE_AR = 18.0
BASELINE_SWEEP_DEG = 25.0
OSWALD_EFFICIENCY = 0.7


def make_optimized_phase_info():
    """Mission with tabular aero; Mach/alt optimized for climb/cruise/descent."""

    def aero_opts():
        return {
            'core_aerodynamics': {
                'method': 'tabular',
                'CD0_data': CD0_data,
                'CDI_data': CDI_data,
                'structured': False,
                'connect_training_data': True,
            }
        }

    return {
        'pre_mission': {
            'include_takeoff': False,
            'optimize_mass': True,
        },

        'climb_1': {
            'subsystem_options': aero_opts(),
            'user_options': {
                'num_segments': 5,
                'order': 3,
                'mach_optimize': True,
                'mach_polynomial_order': 1,
                'mach_initial': (0.2, 'unitless'),
                'mach_final': (0.72, 'unitless'),
                'mach_bounds': ((0.18, 0.74), 'unitless'),

                'altitude_optimize': True,
                'altitude_polynomial_order': 1,
                'altitude_initial': (0.0, 'ft'),
                'altitude_final': (30500.0, 'ft'),
                'altitude_bounds': ((0.0, 31000.0), 'ft'),

                'throttle_enforcement': 'path_constraint',
                'time_initial_bounds': ((0.0, 0.0), 'min'),
                'time_duration_bounds': ((27.0, 81.0), 'min'),
            },
            'initial_guesses': {'time': ([0.0, 54.0], 'min')},
        },

        'cruise': {
            'subsystem_options': aero_opts(),
            'user_options': {
                'num_segments': 5,
                'order': 3,
                'mach_optimize': True,
                'mach_polynomial_order': 1,
                'mach_initial': (0.72, 'unitless'),
                'mach_final': (0.72, 'unitless'),
                'mach_bounds': ((0.7, 0.8), 'unitless'),

                'altitude_optimize': True,
                'altitude_polynomial_order': 3,
                'altitude_initial': (30500.0, 'ft'),
                'altitude_final': (31000.0, 'ft'),
                'altitude_bounds': ((30000.0, 41000.0), 'ft'),

                'throttle_enforcement': 'boundary_constraint',
                'time_initial_bounds': ((27.0, 81.0), 'min'),
                'time_duration_bounds': ((60.0, 350.0), 'min'),
            },
            'initial_guesses': {'time': ([54.0, 117.0], 'min')},
        },

        'descent_1': {
            'subsystem_options': aero_opts(),
            'user_options': {
                'num_segments': 5,
                'order': 3,
                'mach_optimize': True,
                'mach_polynomial_order': 1,
                'mach_initial': (0.72, 'unitless'),
                'mach_final': (0.2, 'unitless'),
                'mach_bounds': ((0.18, 0.8), 'unitless'),

                'altitude_optimize': True,
                'altitude_polynomial_order': 1,
                'altitude_initial': (31000.0, 'ft'),
                'altitude_final': (1500.0, 'ft'),
                'altitude_bounds': ((0.0, 31500.0), 'ft'),

                'throttle_enforcement': 'path_constraint',
                'time_initial_bounds': ((112.5, 337.5), 'min'),
                'time_duration_bounds': ((26.5, 79.5), 'min'),
            },
            'initial_guesses': {'time': ([171.0, 54.0], 'min')},
        },

        'hold': {
            'subsystem_options': aero_opts(),
            'user_options': {
                'num_segments': 3,
                'order': 2,
                'mach_optimize': False,
                'mach_initial': None,
                'mach_final': None,
                'mach_bounds': ((0.15, 0.25), 'unitless'),

                'altitude_optimize': False,
                'altitude_initial': (1500.0, 'ft'),
                'altitude_final': (1500.0, 'ft'),
                'altitude_bounds': ((1000.0, 3000.0), 'ft'),

                'throttle_enforcement': 'path_constraint',
                'time_initial_bounds': ((0.0, 700.0), 'min'),
                'time_duration_bounds': ((45.0, 45.0), 'min'),
            },
            'initial_guesses': {'time': ([225.0, 45.0], 'min')},
        },

        'post_mission': {
            'include_landing': False,
            'constrain_range': True,
            'target_range': (1600.0, 'nmi'),
        },
    }


# Build mission phases (optimized profile by default)
phase_info = make_optimized_phase_info()

# Load aircraft and options data from user
# Allow for user overrides here angain

# Attach JetCost as an external post-mission subsystem
phase_info['post_mission'].setdefault('external_subsystems', [])

# Cost
phase_info['post_mission']['external_subsystems'].append(JetCostBuilder())

prob = av.AviaryProblem()  # Default setting, fuel burn.

prob.load_inputs(aircraft_filename, phase_info)

# Pass the polars to Aviary
#prob.aviary_inputs.set_val(av.Aircraft.Design.LIFT_POLAR, CL_tab, units='unitless')
#prob.aviary_inputs.set_val(av.Aircraft.Design.DRAG_POLAR, CD_tab, units='unitless')

#Check and preprocess inputs to register new data
prob.check_and_preprocess_inputs()

#Update the polars in the problem inputs
prob.aviary_inputs.set_val(
    av.Aircraft.Design.LIFT_INDEPENDENT_DRAG_POLAR,
    cd0_samples,
    units='unitless',
)

prob.aviary_inputs.set_val(
    av.Aircraft.Design.LIFT_DEPENDENT_DRAG_POLAR,
    cdi_samples,
    units='unitless',
)

prob.build_model()

# Create AR + sweep adjustment helper
ar_adjuster = ARAdjustedProblem(prob, cdi_samples, CL_samples, BASELINE_AR, BASELINE_SWEEP_DEG, OSWALD_EFFICIENCY)

prob.add_driver(optimizer, max_iter=max_iter)

attach_ar_update_hooks(prob, ar_adjuster)

# Design Variables
prob.add_design_variables()
# Aspect Ratio
prob.model.add_design_var(av.Aircraft.Wing.ASPECT_RATIO, lower=16.0, upper=20.0, ref=18.0)
# Wing Area
prob.model.add_design_var(av.Aircraft.Wing.AREA, lower=1000.0, upper=1400.0, ref=1220.0)
# Wing Sweep
prob.model.add_design_var(av.Aircraft.Wing.SWEEP, lower=0, upper=25.0, ref=22.0)
# Taper Ratio
prob.model.add_design_var(av.Aircraft.Wing.TAPER_RATIO, lower=0.1, upper=0.5, ref=0.26419)
# Dihedral Angle
prob.model.add_design_var(av.Aircraft.Wing.DIHEDRAL, lower=-5.0, upper=15.0, ref=6.0)
# Fuselage Length
prob.model.add_design_var(av.Aircraft.Fuselage.LENGTH, lower=100.0, upper=150.0, ref=125.0)
# Fuselage Compartment Length
prob.model.add_design_var(av.Aircraft.Fuselage.PASSENGER_COMPARTMENT_LENGTH, lower=80.0, upper=110.0, ref=97.5)
# Fuselage Max Height
prob.model.add_design_var(av.Aircraft.Fuselage.MAX_HEIGHT, lower=12.0, upper=15.0, ref=13.0)
# Fuselage Max Width
prob.model.add_design_var(av.Aircraft.Fuselage.MAX_WIDTH, lower=12.0, upper=15.0, ref=13)

prob.add_objective()
prob.setup()

# ------------------------------
# Quick induced-drag AR correction test (non-invasive)
# This applies a simple induced-drag approx: k = 1/(pi * e * AR)
# and adds k * CL^2 to the lift-dependent drag polar, runs
# a single model evaluation, and prints fuel. It restores the
# original table afterwards.
# ------------------------------
RUN_AR_TEST = False
if RUN_AR_TEST:
    run_ar_sensitivity_test(prob, CL_samples, cdi_samples, ar_values=[30.0, 35.0], e=0.85)

# ===== Cost model economic inputs (non-CSV) =====
apply_default_cost_inputs(prob, Aircraft)

prob.run_aviary_problem(suppress_solver_print=True)
# ================================================

# --- Diagnostic: print initial design variable values and initial model objective ---
print('\n--- Pre-optimization diagnostics ---')
try:
    # run a single model evaluation to get baseline outputs
    prob.run_model()
except Exception as e:
    print('Warning: prob.run_model() failed during pre-optimization check:', e)

def _print_design_state(tag: str = 'state'):
    print(f"\n== {tag} design variables ==")
    try:
        print('Aspect Ratio:', prob.get_val(av.Aircraft.Wing.ASPECT_RATIO))
        print('Wing Area:', prob.get_val(av.Aircraft.Wing.AREA))
        print('Wing Sweep:', prob.get_val(av.Aircraft.Wing.SWEEP))
        print('Taper Ratio:', prob.get_val(av.Aircraft.Wing.TAPER_RATIO))
        print('Dihedral:', prob.get_val(av.Aircraft.Wing.DIHEDRAL))
        print('Fuselage Length:', prob.get_val(av.Aircraft.Fuselage.LENGTH))
    except Exception as e:
        print('Could not read design vars:', e)

try:
    fuel_init = prob.get_val(av.Mission.Summary.FUEL_BURNED)
    print('Initial fuel burn (raw):', fuel_init)
except Exception:
    print('Initial fuel burn not available before run or retrieval failed.')

_print_design_state('initial')

print('\nRunning optimization...')
prob.run_aviary_problem(make_plots=make_plots)

print("\n=== AVIARY GEOMETRY OPTIMIZATION COMPLETE ===\n")

# ------------------------------
# EXTRACT OUTPUTS FOR OAS
# ------------------------------
# Geometry Outputs (coerce 1-element arrays to scalars to avoid numpy deprecation warnings)
MTOW = prob.get_val(av.Mission.Design.GROSS_MASS).item()
AR = prob.get_val(av.Aircraft.Wing.ASPECT_RATIO).item()
S = prob.get_val(av.Aircraft.Wing.AREA).item()
taper = prob.get_val(av.Aircraft.Wing.TAPER_RATIO).item()
sweep = prob.get_val(av.Aircraft.Wing.SWEEP).item()
fuselage_length = prob.get_val(av.Aircraft.Fuselage.LENGTH).item()
fuselage_width = prob.get_val(av.Aircraft.Fuselage.MAX_HEIGHT).item()
fuselage_height = prob.get_val(av.Aircraft.Fuselage.MAX_WIDTH).item()

# Derived geometric quantities needed by OAS
span = np.sqrt(AR * S)              # b = sqrt(AR * S)
c_avg = S / span                    # mean chord
mach = 0.78
alt_ft = 35000.0
alt_m = alt_ft * 0.3048
T = 218.8
a = np.sqrt(1.4 * 287.05 * T)
rho = 0.38  # kg/m^3 typical at 35k ft
n_load = 2.5

# ------------------------------
# PACK INTO DICTIONARY FOR OAS
# ------------------------------

oas_inputs = {
    "aspect_ratio": float(AR),
    "wing_area": float(S),
    "span": float(span),
    "mean_chord": float(c_avg),
    "taper_ratio": float(taper),
    "sweep_deg": float(sweep),
    "aircraft_mass": float(MTOW),
    "rho": rho,
    "mach": mach,
    "speed_of_sound": a,
    "load_factor": n_load,
}

range_nmi = prob.get_val(av.Mission.Summary.RANGE).item()
total_fuel_burn = prob.get_val(av.Mission.Summary.FUEL_BURNED).item()

outputs = {
    "aspect_ratio": AR,
    "wing_area [ft^2]": S,
    "span [ft]": span,
    "mean_chord [ft]": c_avg,
    "taper_ratio": taper,
    "sweep_deg [deg]": sweep,
    "MTOW [lbm]": MTOW,
    "fuselage_length [ft]": fuselage_length,
    "fuselage_width [ft]": fuselage_width,
    "fuselage_height [ft]": fuselage_height,
    "fuselage_Wetted_Area [ft^2]": fuselage_length * fuselage_width * np.pi * (5/6),
    "H.Tail_area [ft^2]": prob.get_val(av.Aircraft.HorizontalTail.AREA).item(),
    "H.Tail_aspect_ratio": prob.get_val(av.Aircraft.HorizontalTail.ASPECT_RATIO).item(),
    "H.Tail_Taper_ratio": prob.get_val(av.Aircraft.HorizontalTail.TAPER_RATIO).item(),
    "H.Tail_wetted_area [ft^2]": prob.get_val(av.Aircraft.HorizontalTail.WETTED_AREA).item(),
    "VV.Tail_area [ft^2]": prob.get_val(av.Aircraft.VerticalTail.AREA).item(),
    "VV.Tail_aspect_ratio": prob.get_val(av.Aircraft.VerticalTail.ASPECT_RATIO).item(),
    "VV.Tail_Taper_ratio": prob.get_val(av.Aircraft.VerticalTail.TAPER_RATIO).item(),
    "VV.Tail_wetted_area [ft^2]": prob.get_val(av.Aircraft.VerticalTail.WETTED_AREA).item(),
    "range [nmi]": range_nmi,
    "total_fuel_burn [lbm]": total_fuel_burn,
}

print("============= GEOMETRY & MISSION OUTPUTS =============")
for k, v in outputs.items():
    print(f"{k:35s} : {v}")
print("======================================================")

# Quick spotlight: trajectory-optimized total fuel burn (lb)
try:
    traj_total_fuel_lb = prob.get_val(av.Mission.Summary.FUEL_BURNED, units='lb').item()
    print(f"\nTrajectory-optimized total fuel burn [lb]: {traj_total_fuel_lb:.3f}")
except Exception as e:
    print("\nCould not retrieve trajectory-optimized total fuel burn:", e)

# === Cost Outputs from JetCost subsystem ===
flyaway        = prob.get_val(Aircraft.Cost.FLYAWAY)[0]
consumer_price = prob.get_val(Aircraft.Cost.CONSUMER_PRICE)[0]
toc            = prob.get_val(Aircraft.Cost.TOTAL_COST_PER_HR)[0]

var_cost       = prob.get_val(Aircraft.Cost.VAR_TOTAL_PER_HR)[0]
fixed_cost     = prob.get_val(Aircraft.Cost.FIXED_TOTAL_ANNUAL)[0]

airframe_man   = prob.get_val(Aircraft.Cost.AIRFRAME_MANUFACTURING)[0]
engine_tot     = prob.get_val(Aircraft.Cost.ENGINE_TOTAL)[0]
direct_man     = prob.get_val(Aircraft.Cost.DIRECT_MANUFACTURING)[0]
ga_overhead    = prob.get_val(Aircraft.Cost.GA_OVERHEAD)[0]
total_man      = prob.get_val(Aircraft.Cost.TOTAL_MANUFACTURING)[0]

lab_hr         = prob.get_val(Aircraft.Cost.MANUFACTURING_LABOR_HOURS)[0]
lab_cost       = prob.get_val(Aircraft.Cost.MANUFACTURING_LABOR)[0]
overhaul       = prob.get_val(Aircraft.Cost.VAR_OVERHAUL_PER_HR)[0]
aux_systems    = prob.get_val(Aircraft.Cost.OPTIONAL_EQUIPMENT)[0]

crew_annual    = prob.get_val(Aircraft.Cost.FIXED_CREW_ANNUAL)[0]

# For fuel uplift cost
burnt_fuel_cost = prob.get_val(Aircraft.Cost.VAR_FUEL_OIL_PER_HR)[0]
fuel_mass      = prob.get_val("mission:summary:total_fuel_mass")[0]      
fuel_density   = prob.get_val("aircraft:fuel:density")[0]               
fuel_price     = prob.get_val(Aircraft.Cost.FUEL_PRICE_PER_GAL)[0] 

print("\n==================== COST RESULTS ====================\n")

# ----- Labor Summary -----
print("----- Labor Summary -----")
print(f"Manufacturing labor hours:       {lab_hr:,.3f} hr")
print(f"Manufacturing labor cost:        {lab_cost:,.3f} USD")

# ----- Manufacturing Breakdown -----
print("\n----- Manufacturing Breakdown -----")
print(f"Airframe manufacturing:          {airframe_man:,.3f} USD")
print(f"Engine total:                    {engine_tot:,.3f} USD")
print(f"Auxiliary systems (avionics/APU):{aux_systems:,.3f} USD")
print(f"Direct manufacturing cost:       {direct_man:,.3f} USD")
print(f"General & admin overhead:        {ga_overhead:,.3f} USD")
print(f"Total manufacturing cost:        {total_man:,.3f} USD")

# ----- Price & Total Economics -----
print("\n----- Price & Total Economics -----")
print(f"Base aircraft price (flyaway):   {flyaway:,.3f} USD")
print(f"Final aircraft price (consumer): {consumer_price:,.3f} USD")

# ----- Operating Cost Items -----
print("\n----- Operating Cost Items -----")
print(f"Total uplifted fuel cost:        {(fuel_mass/fuel_density)*fuel_price:,.3f} USD")
print(f"Fuel cost per mission:           {burnt_fuel_cost:,.3f} USD")
print(f"Total operating cost:            {toc:,.3f} USD/hr")
print(f"Annual crew cost:                {crew_annual:,.3f} USD/year")
print(f"Total fixed operating cost:      {fixed_cost:,.3f} USD/year")

print("\n======================================================\n")

print("\nSaved. You can now pass these into your OAS structural optimization script.\n")

# Emissions Estimation (pass total fuel burn to include CO2 calc)
from emissions import compute_emissions
emissions = compute_emissions(prob, total_fuel_burn, make_plots=True)

# Compute Strucutre
from structure import compute_structure
structural_results = compute_structure(oas_inputs,plot_results=False)